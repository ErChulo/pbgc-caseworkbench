<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>R5 Builder — DOCX Auto-Filler (Browser-only) v0.7.9</title>

  <!-- JSZip via CDN (works on file:// without a local server) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    :root{
      --bg:#0b0d10; --panel:#12161b; --muted:#94a3b8; --text:#e5e7eb;
      --accent:#60a5fa; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444;
      --border:#223043;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    body{ margin:0; font-family:var(--sans); background:var(--bg); color:var(--text); }
    .wrap{ max-width:1100px; margin:0 auto; padding:18px; }
    h1{ font-size:18px; margin:0 0 10px; }
    h2{ font-size:14px; margin:16px 0 8px; color:#cbd5e1; }
    p,li{ color:#cbd5e1; line-height:1.35; }
    .panel{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; }
    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    label{ font-size:12px; color:#cbd5e1; }
    input[type="text"], input[type="number"], textarea{
      background:#0f1318; border:1px solid var(--border); color:var(--text);
      border-radius:10px; padding:9px; min-width:260px;
    }
    textarea{ min-width: 420px; width:100%; min-height: 74px; resize: vertical; font-family: var(--mono); font-size: 12px; }
    input[type="file"]{
      background:#0f1318; border:1px dashed var(--border); color:var(--text);
      border-radius:10px; padding:10px; min-width:320px;
    }
    button{
      background:var(--accent); border:none; color:#071018; font-weight:700;
      border-radius:12px; padding:10px 14px; cursor:pointer;
    }
    button.secondary{
      background:#1f2a37; color:#e5e7eb; border:1px solid var(--border);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .small{ font-size:12px; color:var(--muted); }
    .mono{ font-family:var(--mono); }
    .doclist{ width:100%; border-collapse:collapse; }
    .doclist th,.doclist td{ border-bottom:1px solid var(--border); padding:10px; vertical-align:top; }
    .doclist th{ text-align:left; color:#cbd5e1; font-size:12px; }
    .tag{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; margin-left:8px; }
    .ok{ background:rgba(34,197,94,.18); color:#86efac; border:1px solid rgba(34,197,94,.35); }
    .warn{ background:rgba(245,158,11,.18); color:#fdba74; border:1px solid rgba(245,158,11,.35); }
    .bad{ background:rgba(239,68,68,.18); color:#fecaca; border:1px solid rgba(239,68,68,.35); }
    .hr{ height:1px; background:var(--border); margin:12px 0; }
    .logs{ white-space:pre-wrap; font-family:var(--mono); background:#0f1318; border:1px solid var(--border); border-radius:12px; padding:10px; min-height:90px; }
    a.dl{ display:inline-block; margin:8px 10px 0 0; color:#93c5fd; text-decoration:none; border:1px solid rgba(96,165,250,.35); padding:8px 10px; border-radius:10px; }
    .kbd{ font-family:var(--mono); font-size:12px; padding:2px 6px; border:1px solid var(--border); border-bottom-width:2px; border-radius:8px; background:#0f1318; }
    @media (max-width: 900px){
      .grid{ grid-template-columns:1fr; }
      input[type="text"], textarea{ min-width: 220px; width: 100%; }
      input[type="file"]{ min-width: 220px; width: 100%; }
    }
  </style>
</head>

<body>
<div class="wrap">
  <h1>R5 Builder — DOCX Auto-Filler (Browser-only) v0.7.9</h1>

  <div class="panel">
    <h2>Step 1 — Upload files</h2>
    <div class="row">
      <label>Plan Summary Shell (DOCX)</label><br/>
      <input id="templateFile" type="file" accept=".docx" />
    </div>
    <div class="row" style="margin-top:10px;">
      <label>R5 JSONs (multiple)</label><br/>
      <input id="jsonFiles" type="file" accept=".json,application/json" multiple />
    </div>
    <div class="row" style="margin-top:10px;">
      <label>Case/Document Metadata (optional JSON)</label><br/>
      <input id="metaFile" type="file" accept=".json,application/json" />
    </div>
    <div class="small">Metadata JSON can populate case header fields and per-document Effective Date / Phase-In / Image Viewer IDs. No values are invented.</div>

    <div class="hr"></div>

    <div class="grid">
      <div>
        <h2>Step 2 — Case header (optional)</h2>
        <div class="row"><label>Plan Name</label><br/><input id="planName" type="text" /></div>
        <div class="row"><label>Case Number</label><br/><input id="caseNumber" type="text" /></div>
        <div class="row"><label>Case Processing Section</label><br/><input id="caseProcessingSection" type="text" /></div>
        <div class="row"><label>Actuary</label><br/><input id="actuary" type="text" /></div>
        <div class="row"><label>Auditor</label><br/><input id="auditor" type="text" /></div>

        <div class="row"><label>DOPT</label><br/><input id="dopt" type="text" placeholder="MM/DD/YYYY" /></div>
        <div class="row"><label>DOTR</label><br/><input id="dotr" type="text" placeholder="MM/DD/YYYY" /></div>
        <div class="row"><label>NOD Date</label><br/><input id="nodDate" type="text" placeholder="MM/DD/YYYY" /></div>
        <div class="row"><label>NOIT Date</label><br/><input id="noitDate" type="text" placeholder="MM/DD/YYYY" /></div>
        <div class="row"><label>BPD (Bankruptcy)</label><br/><input id="bpdDate" type="text" placeholder="MM/DD/YYYY" /></div>
        <div class="row"><label>DOBF</label><br/><input id="dobf" type="text" placeholder="MM/DD/YYYY" /></div>
        <div class="row"><label>Facility Closing Date</label><br/><input id="facilityClosingDate" type="text" placeholder="MM/DD/YYYY" /></div>

        <div class="row"><label>Employer Status</label><br/><input id="employerStatus" type="text" /></div>
        <div class="row"><label>Successor Plan</label><br/><input id="successorPlan" type="text" /></div>

        <div class="row"><label>Plan Assets</label><br/><input id="planAssets" type="text" /></div>
        <div class="row"><label>Funding Status</label><br/><input id="fundingStatus" type="text" /></div>
        <div class="row"><label>SPARR</label><br/><input id="sparr" type="text" /></div>
      </div>

      <div>
        <h2>Step 3 — PBGC rates (from metadata, editable)</h2>
        <div class="small">These fields are written into the 2nd table on page 1 of the Shell.</div>

        <div class="row" style="margin-top:10px; width:100%;">
          <label>PBGC Lump Sum Rates — Immediate Rate</label><br/>
          <textarea id="pbgcLumpImmediate" placeholder="Example (multi-line):&#10;0.87% for 5 years&#10;2.74% for 15 years&#10;3.16% thereafter"></textarea>
        </div>

        <div class="row" style="margin-top:10px; width:100%;">
          <label>PBGC Lump Sum Rates — Deferral Rate</label><br/>
          <textarea id="pbgcLumpDeferral" placeholder="Example: 8.4%"></textarea>
        </div>

        <div class="row" style="margin-top:10px; width:100%;">
          <label>PBGC Annuity Rates</label><br/>
          <textarea id="pbgcAnnuityRates" placeholder="Example (multi-line):&#10;2.40% for 20 years&#10;2.11% thereafter"></textarea>
        </div>
      </div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <label><input id="includeCitation" type="checkbox" checked /> Include citation line under each answer</label>
    </div>
  </div>

  <div class="panel" style="margin-top:14px;">
    <h2>Loaded documents (order matters)</h2>
    <div class="small">The template supports 3 document columns per output DOCX. If you load more than 3 documents, the app will generate multiple DOCXs and bundle them in a ZIP.</div>
    <div class="hr"></div>

    <table class="doclist" id="docTable">
      <thead>
        <tr>
          <th style="width:28px;">#</th>
          <th>Document</th>
          <th style="min-width:280px;">Metadata used in Shell</th>
          <th style="width:170px;">Actions</th>
        </tr>
      </thead>
      <tbody id="docTbody">
        <tr><td colspan="4" class="small">No JSONs loaded yet.</td></tr>
      </tbody>
    </table>

    <div class="hr"></div>
    <div class="row">
      <button id="generateBtn" disabled>Generate R5 DOCX</button>
      <button id="clearBtn" class="secondary">Clear</button>
      <span id="statusPill" class="tag warn">Waiting for files</span>
    </div>

    <h2>Output</h2>
    <div id="downloads" class="row"></div>

    <h2>Run report</h2>
    <div id="report" class="logs"></div>
  </div>

  <div class="panel" style="margin-top:14px;">
    <h2>Troubleshooting</h2>
    <ul>
      <li>If status says <span class="kbd">JSZip not loaded</span>, your network blocks CDNs. Fix: run with internet or use a local server and a local JSZip file.</li>
      <li>If Word shows “We found a problem with some content”, it usually means <span class="mono">word/document.xml</span> got malformed. The report will show the exact row/item that caused it.</li>
      <li>If some rows remain blank: confirm your JSON includes <span class="mono">item_id</span> 1–61 with non-empty <span class="mono">answer</span>.</li>
    </ul>
  </div>
</div>

<script>
(() => {
  // ---- Constants ----
  const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

  // Mapping: R5 item_id -> row index in the Plan Provisions table (3rd table in shell)
  const ITEM_TO_ROW = {
    1: 2,  2: 5,  3: 9,  4: 10, 5: 11,
    6: 13, 7: 14, 8: 15, 9: 16, 10: 17,
    11: 18, 12: 19, 13: 20, 14: 21,
    15: 23, 16: 24, 17: 25, 18: 26,
    19: 28, 20: 29, 21: 30, 22: 31,
    23: 32, 24: 33, 25: 34,
    26: 36, 27: 37, 28: 38, 29: 39, 30: 40, 31: 41,
    32: 43, 33: 44, 34: 45,
    35: 47, 36: 48, 37: 49,
    38: 50, 39: 51, 40: 52,
    41: 53, 42: 55, 43: 56,
    44: 58, 45: 59, 46: 60,
    47: 61, 48: 63, 49: 64, 50: 65, 51: 66,
    52: 68, 53: 69, 54: 70, 55: 71, 56: 72, 57: 73,
    58: 74, 59: 75, 60: 76, 61: 77
  };

  // ---- DOM ----
  const elTemplate = document.getElementById("templateFile");
  const elJsons = document.getElementById("jsonFiles");
  const elMetaFile = document.getElementById("metaFile");
  const elGenerate = document.getElementById("generateBtn");
  const elClear = document.getElementById("clearBtn");
  const elTbody = document.getElementById("docTbody");
  const elReport = document.getElementById("report");
  const elDownloads = document.getElementById("downloads");
  const elIncludeCitation = document.getElementById("includeCitation");
  const elStatus = document.getElementById("statusPill");

  // Case header inputs
  const elPlanName = document.getElementById("planName");
  const elCaseNumber = document.getElementById("caseNumber");
  const elCaseProcessingSection = document.getElementById("caseProcessingSection");
  const elActuary = document.getElementById("actuary");
  const elAuditor = document.getElementById("auditor");
  const elDopt = document.getElementById("dopt");
  const elDotr = document.getElementById("dotr");
  const elNodDate = document.getElementById("nodDate");
  const elNoitDate = document.getElementById("noitDate");
  const elBpdDate = document.getElementById("bpdDate");
  const elDobf = document.getElementById("dobf");
  const elFacilityClosingDate = document.getElementById("facilityClosingDate");
  const elEmployerStatus = document.getElementById("employerStatus");
  const elSuccessorPlan = document.getElementById("successorPlan");
  const elPlanAssets = document.getElementById("planAssets");
  const elFundingStatus = document.getElementById("fundingStatus");
  const elSparr = document.getElementById("sparr");

  // PBGC rates inputs
  const elPbgcLumpImmediate = document.getElementById("pbgcLumpImmediate");
  const elPbgcLumpDeferral = document.getElementById("pbgcLumpDeferral");
  const elPbgcAnnuityRates = document.getElementById("pbgcAnnuityRates");

  // ---- State ----
  let templateBytes = null;
  let docs = []; // { fileName, document, itemsById, meta:{effectiveDate,phaseIn,imageViewer}, problems:[] }
  let meta = null;

  // ---- Helpers ----
  const log = (s) => { elReport.textContent += s + "\n"; };
  const resetLog = () => { elReport.textContent = ""; };
  const setStatus = (kind, text) => {
    elStatus.classList.remove("ok","warn","bad");
    elStatus.classList.add(kind);
    elStatus.textContent = text;
  };
  const safeText = (s) => (s===null || s===undefined) ? "" : String(s);
  const norm = (s) => safeText(s).replace(/\u00a0/g," ").replace(/\s+/g," ").trim();
  const normLower = (s) => norm(s).toLowerCase();

  function readFileAsArrayBuffer(file){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(fr.error);
      fr.readAsArrayBuffer(file);
    });
  }
  function readFileAsText(file){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(fr.error);
      fr.readAsText(file);
    });
  }
  function downloadBlob(filename, blob){
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename;
    a.className = "dl";
    a.textContent = "Download " + filename;
    elDownloads.appendChild(a);
  }

  // ---- WordprocessingML helpers ----
  function isW(el, localName){
    return el && el.nodeType === 1 && (el.localName === localName) && (el.namespaceURI === W_NS);
  }
  function directChildren(parent, localName){
    const out = [];
    for (const n of Array.from(parent.childNodes || [])){
      if (isW(n, localName)) out.push(n);
    }
    return out;
  }
  function descendants(parent, localName){
    return Array.from(parent.getElementsByTagNameNS(W_NS, localName));
  }
  function qAll(node, localName){ return descendants(node, localName); }
  function q1(node, localName){
    const arr = descendants(node, localName);
    return arr.length ? arr[0] : null;
  }
  function firstChild(parent, localName){
    for (const n of Array.from(parent.childNodes || [])){
      if (isW(n, localName)) return n;
    }
    return null;
  }
  function attrVal(el, local){
    if (!el || !el.attributes) return null;
    let v = el.getAttribute("w:"+local) || el.getAttribute(local);
    if (v) return v;
    for (const a of el.attributes){
      if ((a.name||"").endsWith(":"+local)) return a.value;
    }
    return null;
  }

  function getCellByGridCol(tr, gridCol){
    // gridCol: 0..N
    const tcs = directChildren(tr, "tc");
    let col = 0;
    for (const tc of tcs){
      const tcPr = firstChild(tc, "tcPr");
      const gsEl = tcPr ? firstChild(tcPr, "gridSpan") : null;
      const span = gsEl ? parseInt(attrVal(gsEl,"val") || "1", 10) : 1;
      if (gridCol >= col && gridCol < col + span){
        return tc;
      }
      col += span;
    }
    return null;
  }

  function setCellText(xmlDoc, tc, text){
    const lines = safeText(text).split(/\r?\n/);
    let p = q1(tc, "p");
    if (!p){
      p = xmlDoc.createElementNS(W_NS, "w:p");
      tc.appendChild(p);
    }
    const pPr = firstChild(p, "pPr");
    const kids = Array.from(p.childNodes);
    for (const k of kids){
      if (pPr && k === pPr) continue;
      p.removeChild(k);
    }
    function addRunWithText(t){
      const r = xmlDoc.createElementNS(W_NS, "w:r");
      const tt = xmlDoc.createElementNS(W_NS, "w:t");
      tt.setAttribute("xml:space","preserve");
      tt.textContent = t;
      r.appendChild(tt);
      p.appendChild(r);
    }
    function addBreak(){
      const r = xmlDoc.createElementNS(W_NS, "w:r");
      const br = xmlDoc.createElementNS(W_NS, "w:br");
      r.appendChild(br);
      p.appendChild(r);
    }
    lines.forEach((ln, i) => {
      addRunWithText(ln);
      if (i < lines.length-1) addBreak();
    });
  }

  function getCellPlainText(tc){
    const txt = safeText(tc.textContent || "");
    return norm(txt);
  }

  function findHeaderTable(xmlDoc){
    const tables = qAll(xmlDoc, "tbl");
    for (const tbl of tables){
      const t = normLower(tbl.textContent || "");
      if (t.includes("plan name:") && t.includes("case number:")) return tbl;
    }
    return tables.length ? tables[0] : null;
  }

  function fillHeaderTableByLabels(xmlDoc){
    const tbl = findHeaderTable(xmlDoc);
    if (!tbl) return;

    const rows = directChildren(tbl, "tr");
    const map = [
      { label:"Plan Name:", value: elPlanName.value },
      { label:"Case Number:", value: elCaseNumber.value },
      { label:"Case Processing Section:", value: elCaseProcessingSection.value },
      { label:"Actuary:", value: elActuary.value },
      { label:"Auditor:", value: elAuditor.value },
      { label:"DOPT:", value: elDopt.value },
      { label:"DOTR:", value: elDotr.value },
      { label:"NOD Date:", value: elNodDate.value },
      { label:"NOIT Date:", value: elNoitDate.value },
      { label:"BPD (Bankruptcy):", value: elBpdDate.value },
      { label:"DOBF:", value: elDobf.value },
      { label:"Facility Closing Date:", value: elFacilityClosingDate.value },
      { label:"Employer Status:", value: elEmployerStatus.value },
      { label:"Successor Plan:", value: elSuccessorPlan.value },
      { label:"Plan Assets:", value: elPlanAssets.value },
      { label:"Funding Status:", value: elFundingStatus.value },
      { label:"SPARR:", value: elSparr.value }
    ];

    const want = new Map(map.map(x => [normLower(x.label), x.value]));
    if (![...want.values()].some(v => norm(v) !== "")) return;

    for (const tr of rows){
      const tcs = directChildren(tr, "tc");
      for (let i=0; i<tcs.length-1; i++){
        const here = norm(getCellPlainText(tcs[i]));
        if (!here.endsWith(":")) continue;

        const key = normLower(here);
        if (!want.has(key)) continue;

        const v = safeText(want.get(key)).trim();
        if (!v) continue;

        const tcValue = tcs[i+1];
        setCellText(xmlDoc, tcValue, v);
      }
    }
  }

  function findPbgcRatesTable(xmlDoc){
    const tables = qAll(xmlDoc, "tbl");
    for (const tbl of tables){
      const t = normLower(tbl.textContent || "");
      if (t.includes("pbgc lump sum rates:") && t.includes("pbgc annuity rates:")) return tbl;
    }
    return null;
  }

  function splitLines(s){
    return safeText(s).split(/\r?\n/).map(x=>x.trim()).filter(x=>x.length>0);
  }

  // v0.7.9 FIX: write PBGC rates by finding the label cells and writing into the correct cells
  function fillPbgcRatesTable(xmlDoc){
    const tbl = findPbgcRatesTable(xmlDoc);
    if (!tbl) return;

    const lumpImmediate = safeText(elPbgcLumpImmediate.value).trim();
    const lumpDeferral = safeText(elPbgcLumpDeferral.value).trim();
    const annuityRates = safeText(elPbgcAnnuityRates.value).trim();

    const hasAny = (lumpImmediate || lumpDeferral || annuityRates);
    if (!hasAny) return;

    const rows = directChildren(tbl, "tr");

    // detect segment-style table (First/Second/Third Segment)
    const tblText = normLower(tbl.textContent || "");
    const segmentMode = tblText.includes("first segment:") && tblText.includes("second segment:");

    if (segmentMode){
      // Map lumpImmediate lines to first/second/third segment cells
      const lines = splitLines(lumpImmediate);
      const want = {
        "first segment:": (lines[0] ?? ""),
        "second segment:": (lines[1] ?? ""),
        "third segment:": (lines[2] ?? "")
      };

      for (const tr of rows){
        const tcs = directChildren(tr, "tc");
        for (const tc of tcs){
          const txt = normLower(getCellPlainText(tc));
          for (const k of Object.keys(want)){
            if (txt.startsWith(k) && want[k]){
              // preserve label, replace value
              const label = k.replace(/\s+/g," ").replace(/^(\w)/, c=>c.toUpperCase()); // crude cap
              // keep original label casing if possible
              const orig = norm(getCellPlainText(tc));
              const prefix = orig.split(":")[0] + ":";
              setCellText(xmlDoc, tc, `${prefix} ${want[k]}`);
            }
          }
        }
      }
    } else {
      // Immediate/Deferral style: append value into the same label cell (do NOT touch annuity cells)
      for (const tr of rows){
        const tcs = directChildren(tr, "tc");
        for (const tc of tcs){
          const txt = normLower(getCellPlainText(tc));
          if (txt.startsWith("immediate rate:") && lumpImmediate){
            setCellText(xmlDoc, tc, "Immediate Rate:\n" + lumpImmediate);
          }
          if (txt.startsWith("deferral rate:") && lumpDeferral){
            setCellText(xmlDoc, tc, "Deferral Rate:\n" + lumpDeferral);
          }
        }
      }
    }

    // Annuity rates: write into the cell(s) immediately to the right of "PBGC Annuity Rates:"
    if (annuityRates){
      const lines = splitLines(annuityRates);

      for (let r=0; r<rows.length; r++){
        const tr = rows[r];
        const tcs = directChildren(tr, "tc");
        for (let c=0; c<tcs.length-1; c++){
          const txt = normLower(getCellPlainText(tcs[c]));
          if (txt.includes("pbgc annuity rates:")){
            const val0 = tcs[c+1];

            if (lines.length === 1){
              setCellText(xmlDoc, val0, lines[0]);
              return;
            }

            // If subsequent rows have a value cell in the same column index (c+1), fill line-by-line.
            setCellText(xmlDoc, val0, lines[0]);

            for (let k=1; k<lines.length; k++){
              const rr = r + k;
              if (rr < rows.length){
                const trr = rows[rr];
                const tcs2 = directChildren(trr, "tc");
                if (tcs2.length > (c+1)){
                  setCellText(xmlDoc, tcs2[c+1], lines[k]);
                } else {
                  // fallback: append to first value cell
                  setCellText(xmlDoc, val0, [lines[0], ...lines.slice(1)].join("\n"));
                  return;
                }
              } else {
                setCellText(xmlDoc, val0, [lines[0], ...lines.slice(1)].join("\n"));
                return;
              }
            }
            return;
          }
        }
      }
    }
  }

  function findPlanProvisionsTable(xmlDoc){
    const tables = qAll(xmlDoc, "tbl");
    for (const tbl of tables){
      const txt = safeText(tbl.textContent || "");
      const rows = qAll(tbl, "tr").length;
      if (txt.includes("Plan Provisions") && rows >= 70) return tbl;
    }
    return null;
  }

  // ---- JSON normalization ----
  function normalizeR5Json(obj, fileName){
    let document = obj.document || obj.doc || obj.plan_document || obj.plan || {};
    if (typeof document === "string") document = { name: document };
    if (!document || typeof document !== "object") document = {};
    if (!document.name) document.name = obj.document_name || obj.doc_name || obj.title || fileName;

    let rawItems = obj.items || obj.r5_items || obj.answers || obj.responses || null;
    let arr = [];

    if (Array.isArray(rawItems)){
      arr = rawItems.slice();
    } else if (rawItems && typeof rawItems === "object"){
      for (const [k,v] of Object.entries(rawItems)){
        const id = (v && typeof v === "object" && Number.isFinite(v.item_id)) ? v.item_id : parseInt(k, 10);
        if (!Number.isFinite(id)) continue;
        if (!v || typeof v !== "object") continue;
        arr.push({ item_id: id, ...v });
      }
    }

    if (!arr.length){
      for (const [k,v] of Object.entries(obj)){
        const id = parseInt(k, 10);
        if (!(id>=1 && id<=61)) continue;
        if (!v || typeof v !== "object") continue;
        arr.push({ item_id: id, ...v });
      }
    }

    arr = arr
      .filter(it => Number.isFinite(it.item_id))
      .map(it => {
        const answer = (it.answer ?? it.summary_1line ?? it.summary ?? it.text ?? it.value ?? "").toString().trim();
        let citation_note = (it.citation_note ?? it.citation ?? it.source ?? it.ref ?? "").toString().trim();
        if (!citation_note && Array.isArray(it.references) && it.references.length){
          const r = it.references[0] || {};
          const sec = (r.section || r.sec || "").toString().trim();
          const pdfp = (r.page_pdf || r.pdf_page || r.page || "").toString().trim();
          const parts = [];
          if (sec) parts.push(sec);
          if (pdfp) parts.push("pdf p" + pdfp);
          citation_note = parts.length ? "(" + parts.join("; ") + ")" : "";
        }
        return {
          item_id: Number(it.item_id),
          item_text: (it.item_text ?? it.label ?? it.question ?? "").toString(),
          status: (it.status ?? "value").toString().toLowerCase(),
          answer,
          citation_note,
          references: it.references || []
        };
      });

    return { document, items: arr };
  }

  // ---- Metadata apply ----
  function applyMetadata(){
    if (!meta || typeof meta !== "object") return;

    const c = meta.case || meta.header || meta.preamble || meta || {};
    const dep = meta.dependent_fields || meta.dependentFields || {};

    const setIf = (el, v) => { if (v !== undefined && v !== null && String(v).trim() !== "") el.value = String(v); };

    setIf(elPlanName, c.plan_name ?? c.planName);
    setIf(elCaseNumber, c.case_number ?? c.caseNumber);
    setIf(elCaseProcessingSection, c.case_processing_section ?? c.caseProcessingSection);
    setIf(elActuary, c.actuary);
    setIf(elAuditor, c.auditor);

    setIf(elDopt, c.dopt);
    setIf(elDotr, c.dotr);
    setIf(elNodDate, c.nod_date ?? c.nodDate);
    setIf(elNoitDate, c.noit_date ?? c.noitDate);
    setIf(elBpdDate, c.bpd ?? c.bpd_date ?? c.bpdDate);
    setIf(elDobf, c.dobf);
    setIf(elFacilityClosingDate, c.facility_closing_date ?? c.facilityClosingDate);

    setIf(elEmployerStatus, c.employer_status ?? c.employerStatus);
    setIf(elSuccessorPlan, c.successor_plan ?? c.successorPlan);
    setIf(elPlanAssets, c.plan_assets ?? c.planAssets);
    setIf(elFundingStatus, c.funding_status ?? c.fundingStatus);
    setIf(elSparr, c.sparr);

    setIf(elPbgcLumpImmediate, dep.pbgc_lump_sum_immediate_rate ?? dep.pbgcLumpSumImmediateRate);
    setIf(elPbgcLumpDeferral, dep.pbgc_lump_sum_deferral_rate ?? dep.pbgcLumpSumDeferralRate);
    setIf(elPbgcAnnuityRates, dep.pbgc_annuity_rates ?? dep.pbgcAnnuityRates);

    const docsMeta = meta.documents || meta.plan_documents || meta.docs || [];
    if (Array.isArray(docsMeta) && docsMeta.length){
      for (const dm of docsMeta){
        const sf = (dm.source_file ?? dm.sourceFile ?? "").toString();
        const nm = (dm.name ?? dm.document_name ?? "").toString();
        const id = (dm.doc_id ?? dm.docId ?? "").toString();

        const target = docs.find(d => {
          const dName = safeText(d.document?.name || "");
          const dId = safeText(d.document?.doc_id || "");
          const dFile = safeText(d.fileName || "");
          return (sf && dFile === sf) || (nm && dName === nm) || (id && dId === id);
        });

        if (!target) continue;
        if ((dm.effective_date ?? dm.effectiveDate) !== undefined) target.meta.effectiveDate = String(dm.effective_date ?? dm.effectiveDate);
        if ((dm.phase_in ?? dm.phaseIn) !== undefined) target.meta.phaseIn = String(dm.phase_in ?? dm.phaseIn);
        if ((dm.image_viewer ?? dm.imageViewer) !== undefined) target.meta.imageViewer = String(dm.image_viewer ?? dm.imageViewer);
      }
    }

    log("Metadata applied.");
  }

  function escapeHtml(s){
    return safeText(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }
  function escapeAttr(s){ return escapeHtml(s); }

  function buildDocUI(){
    if (!docs.length){
      elTbody.innerHTML = `<tr><td colspan="4" class="small">No JSONs loaded yet.</td></tr>`;
      return;
    }
    elTbody.innerHTML = "";
    docs.forEach((d, idx) => {
      const tr = document.createElement("tr");
      const name = safeText(d.document?.name || d.fileName || `Doc ${idx+1}`);
      const eff = safeText(d.meta.effectiveDate || "");
      const pin = safeText(d.meta.phaseIn || "");
      const ivn = safeText(d.meta.imageViewer || "");
      const parsedCount = d.itemsById.size;

      const miss = d.problems.length
        ? `<span class="tag bad">${d.problems.length} issues</span> <span class="tag warn">${parsedCount}/61 parsed</span>`
        : `<span class="tag ok">OK</span> <span class="tag ok">${parsedCount}/61 parsed</span>`;

      tr.innerHTML = `
        <td class="mono">${idx+1}</td>
        <td>
          <div><b>${escapeHtml(name)}</b> ${miss}</div>
          <div class="small mono">${escapeHtml(d.fileName)}</div>
        </td>
        <td>
          <div class="small">Effective Date</div>
          <input data-k="effectiveDate" data-i="${idx}" type="text" value="${escapeAttr(eff)}" />
          <div class="small" style="margin-top:8px;">Phase-In</div>
          <input data-k="phaseIn" data-i="${idx}" type="text" value="${escapeAttr(pin)}" />
          <div class="small" style="margin-top:8px;">Image Viewer Document Number(s)</div>
          <input data-k="imageViewer" data-i="${idx}" type="text" value="${escapeAttr(ivn)}" />
        </td>
        <td>
          <div class="row">
            <button class="secondary" data-act="up" data-i="${idx}" ${idx===0?"disabled":""}>Up</button>
            <button class="secondary" data-act="down" data-i="${idx}" ${idx===docs.length-1?"disabled":""}>Down</button>
            <button class="secondary" data-act="remove" data-i="${idx}">Remove</button>
          </div>
        </td>
      `;
      elTbody.appendChild(tr);
    });

    elTbody.querySelectorAll("input[data-k]").forEach(inp => {
      inp.addEventListener("input", (e) => {
        const i = parseInt(e.target.getAttribute("data-i"),10);
        const k = e.target.getAttribute("data-k");
        docs[i].meta[k] = e.target.value;
      });
    });

    elTbody.querySelectorAll("button[data-act]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = parseInt(btn.getAttribute("data-i"),10);
        const act = btn.getAttribute("data-act");
        if (act === "up" && i>0){
          [docs[i-1], docs[i]] = [docs[i], docs[i-1]];
        } else if (act === "down" && i<docs.length-1){
          [docs[i+1], docs[i]] = [docs[i], docs[i+1]];
        } else if (act === "remove"){
          docs.splice(i,1);
        }
        buildDocUI();
        updateReadyState();
      });
    });
  }

  function updateReadyState(){
    const jszipOk = !!window.JSZip;
    const ready = jszipOk && !!templateBytes && docs.length>0;
    elGenerate.disabled = !ready;

    if (!jszipOk) setStatus("bad","JSZip not loaded");
    else if (!templateBytes) setStatus("warn","Upload template DOCX");
    else if (!docs.length) setStatus("warn","Upload JSONs");
    else setStatus("ok","Ready");
  }

  // ---- File loading ----
  elTemplate.addEventListener("change", async () => {
    resetLog();
    elDownloads.innerHTML = "";
    const f = elTemplate.files && elTemplate.files[0];
    if (!f){ templateBytes=null; updateReadyState(); return; }
    try{
      templateBytes = await readFileAsArrayBuffer(f);
      log("Template loaded: " + f.name + " (" + templateBytes.byteLength + " bytes)");
    } catch(err){
      templateBytes = null;
      log("ERROR loading template: " + err);
    }
    updateReadyState();
  });

  elJsons.addEventListener("change", async () => {
    resetLog();
    elDownloads.innerHTML = "";
    docs = [];
    const files = Array.from(elJsons.files || []);
    if (!files.length){ buildDocUI(); updateReadyState(); return; }

    for (const f of files){
      const d = { fileName: f.name, document: null, itemsById: new Map(), meta: { effectiveDate:"", phaseIn:"", imageViewer:"" }, problems: [] };
      try{
        const txt = await readFileAsText(f);
        const obj = JSON.parse(txt);
        const normed = normalizeR5Json(obj, f.name);
        d.document = normed.document || {};
        const items = Array.isArray(normed.items) ? normed.items : [];
        for (const it of items){
          if (Number.isFinite(it?.item_id)) d.itemsById.set(Number(it.item_id), it);
        }
        for (let k=1; k<=61; k++){
          if (!d.itemsById.has(k)) d.problems.push("Missing item_id " + k);
        }
        d.meta.effectiveDate = safeText(d.document?.effective_date || "");
        docs.push(d);
      } catch(err){
        d.problems.push("JSON parse error: " + err);
        docs.push(d);
      }
    }

    log("Loaded JSON documents: " + docs.length);
    if (meta) applyMetadata();
    buildDocUI();
    updateReadyState();
  });

  elMetaFile.addEventListener("change", async () => {
    const f = elMetaFile.files && elMetaFile.files[0];
    if (!f){ meta = null; log("Metadata cleared."); return; }
    try{
      const txt = await readFileAsText(f);
      meta = JSON.parse(txt);
      log("Metadata loaded: " + f.name);
      applyMetadata();
      buildDocUI();
      updateReadyState();
    } catch(err){
      meta = null;
      log("ERROR loading metadata JSON: " + err);
    }
  });

  elClear.addEventListener("click", () => {
    templateBytes = null;
    docs = [];
    elTemplate.value = "";
    elJsons.value = "";
    elMetaFile.value = "";
    meta = null;
    elDownloads.innerHTML = "";
    resetLog();
    buildDocUI();
    updateReadyState();
  });

  // ---- Generation core ----
  async function generateOneDocxForChunk(chunkDocs, partIndex, totalDocsCount){
    if (!window.JSZip) throw new Error("JSZip not loaded.");
    const zip = await JSZip.loadAsync(templateBytes);
    const xmlBytes = await zip.file("word/document.xml").async("uint8array");
    const xmlStr = new TextDecoder("utf-8").decode(xmlBytes);

    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlStr, "application/xml");
    const parseErr = xmlDoc.getElementsByTagName("parsererror")[0];
    if (parseErr) throw new Error("XML parse error in template document.xml");

    // Fill header (by labels) + PBGC rates table (by labels)
    fillHeaderTableByLabels(xmlDoc);
    fillPbgcRatesTable(xmlDoc);

    const tbl = findPlanProvisionsTable(xmlDoc);
    if (!tbl) throw new Error("Could not locate Plan Provisions table (expected text 'Plan Provisions').");

    const rows = directChildren(tbl, "tr");

    // For each of the 3 document columns
    for (let col=1; col<=3; col++){
      const docIdx = col-1;
      const d = chunkDocs[docIdx] || null;

      // Effective Date / Phase-In row (row index 1)
      const tr1 = rows[1];
      if (tr1){
        const tc = getCellByGridCol(tr1, col);
        if (tc){
          if (d){
            const eff = safeText(d.meta.effectiveDate || "");
            const ph = safeText(d.meta.phaseIn || "");
            setCellText(xmlDoc, tc, `Effective Date: ${eff}\nPhase-In: ${ph}`);
          } else {
            setCellText(xmlDoc, tc, `Effective Date:\nPhase-In:`);
          }
        }
      }

      // Image Viewer Doc # row (row index 6)
      const trImg = rows[6];
      if (trImg){
        const tc = getCellByGridCol(trImg, col);
        if (tc){
          if (d) setCellText(xmlDoc, tc, safeText(d.meta.imageViewer || ""));
          else setCellText(xmlDoc, tc, "");
        }
      }

      // Fill items 1..61
      let missing = 0, written = 0;

      for (let itemId=1; itemId<=61; itemId++){
        const rowIdx = ITEM_TO_ROW[itemId];
        const tr = rows[rowIdx];
        if (!tr) continue;

        const tc = getCellByGridCol(tr, col);
        if (!tc) continue;

        if (!d){
          setCellText(xmlDoc, tc, "");
          continue;
        }

        const it = d.itemsById.get(itemId);
        const status = safeText(it?.status || "value").toLowerCase().trim();
        const ans = safeText(it?.answer || "").trim();
        const cit = safeText(it?.citation_note || "").trim();

        if (status === "blank"){
          setCellText(xmlDoc, tc, "");
          continue;
        }
        if (!ans){
          missing++;
          setCellText(xmlDoc, tc, "");
          continue;
        }

        const displayText = ans;
        const citationLine = elIncludeCitation.checked ? (cit ? cit : "") : "";
        const payload = citationLine ? `${displayText}\n${citationLine}` : displayText;
        setCellText(xmlDoc, tc, payload);
        written++;
      }

      if (d) d._lastStats = { missing, written };
    }

    const outXml = new XMLSerializer().serializeToString(xmlDoc);
    zip.file("word/document.xml", outXml);

    const outBytes = await zip.generateAsync({ type: "uint8array" });
    const blob = new Blob([outBytes], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });

    const baseCase = (elCaseNumber.value || "TESTCASE").replace(/[^\w\-]+/g,"_");
    const total = totalDocsCount ?? docs.length;
    const fileName = (total <= 3) ? `${baseCase}R5_v0.7.9.docx` : `${baseCase}R5_v0.7.9_part${partIndex+1}.docx`;

    return { fileName, blob };
  }

  async function generateAll(){
    if (!window.JSZip) throw new Error("JSZip not loaded.");
    if (!templateBytes) throw new Error("No template DOCX loaded.");
    if (!docs.length) throw new Error("No JSON documents loaded.");

    resetLog();
    elDownloads.innerHTML = "";

    const chunks = [];
    for (let i=0; i<docs.length; i+=3) chunks.push(docs.slice(i, i+3));

    log(`Generating outputs for ${docs.length} document(s) => ${chunks.length} output file(s).`);

    const outputs = [];
    for (let ci=0; ci<chunks.length; ci++){
      const chunk = chunks[ci];
      const out = await generateOneDocxForChunk(chunk, ci, docs.length);
      outputs.push(out);
      downloadBlob(out.fileName, out.blob);

      chunk.forEach(d => {
        const s = d._lastStats || {};
        log(`Doc: ${safeText(d.document?.name || d.fileName)} | written=${s.written ?? 0} | missing=${s.missing ?? 0}`);
      });
    }

    if (outputs.length > 1){
      const z = new JSZip();
      for (const o of outputs){
        const ab = await o.blob.arrayBuffer();
        z.file(o.fileName, ab);
      }
      const zipBlob = await z.generateAsync({type:"blob"});
      const baseCase = (elCaseNumber.value || "TESTCASE").replace(/[^\w\-]+/g,"_");
      downloadBlob(`${baseCase}R5_v0.7.9_outputs.zip`, zipBlob);
      log("ZIP bundle created.");
    }

    setStatus("ok", `Done: ${outputs.length} file(s)`);
  }

  elGenerate.addEventListener("click", async () => {
    try{
      await generateAll();
    } catch(err){
      setStatus("bad","Error");
      log("ERROR: " + (err && err.message ? err.message : err));
      console.error(err);
    }
  });

  // initial
  updateReadyState();
})();
</script>
</body>
</html>